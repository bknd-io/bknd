---
title: 'Filtering by Relations'
description: 'How to filter entities based on related data in many-to-many relationships'
---

You often need to retrieve entries from one entity based on properties of a related entity (for example, get all Teachers who teach "Math"). In bknd, this is handled via the REST API using the `where` clause with dot notation, together with the `join` parameter.

## Understanding `join` vs `with`

Before diving into examples, it's crucial to understand the functional difference between these two parameters:

- **`join`**: Enables filtering by related entity fields using dot notation. This parameter tells the database to join the related table so you can reference its fields in your `where` conditions. The related data is **not** included in the response unless you also use `with`.

- **`with`**: Embeds related entity data in the response. This parameter tells the API to include the full related objects in the returned results. You can use `with` without `join` if you only want to embed data without filtering by it.

**Key Point**: `join` is about **filtering capabilities**, while `with` is about **response structure**.

## Example Use Case

You have:
- An entity: `Teacher`
- Another entity: `Subject`
- Many-to-many relation between them (a Teacher can have many Subjects, and vice versa).

You want to find Teachers that have a Subject with the name 'Math'.

## Examples by Use Case

### 1. Filter by Related Data (join only)

When you want to filter by related entity fields but don't need the related data in the response:

```
GET /api/data/entity/teacher?where={"subject.name":"Math"}&join=subject
```

**Result**: Returns teachers who teach Math, but the response only contains teacher data (no embedded subject information).

```json
{
  "data": [
    {
      "id": 1,
      "name": "John Smith",
      "email": "john@school.edu"
    }
  ]
}
```

### 2. Embed Related Data (with only)

When you want to include related data in the response without filtering by it:

```
GET /api/data/entity/teacher?with=subject
```

**Result**: Returns all teachers with their subjects embedded in the response.

```json
{
  "data": [
    {
      "id": 1,
      "name": "John Smith",
      "email": "john@school.edu",
      "subject": [
        {
          "id": 1,
          "name": "Math",
          "description": "Mathematics course"
        },
        {
          "id": 2,
          "name": "Physics",
          "description": "Physics course"
        }
      ]
    }
  ]
}
```

### 3. Filter and Embed (join + with)

When you want both to filter by related data AND include it in the response:

```
GET /api/data/entity/teacher?where={"subject.name":"Math"}&join=subject&with=subject
```

**Result**: Returns teachers who teach Math, with their subject data embedded.

```json
{
  "data": [
    {
      "id": 1,
      "name": "John Smith",
      "email": "john@school.edu",
      "subject": [
        {
          "id": 1,
          "name": "Math",
          "description": "Mathematics course"
        }
      ]
    }
  ]
}
```

<Note>
If no operation is provided in the where clause, `$eq` (equals) is assumed by default. So `{"subject.name": "Math"}` is the same as `{"subject.name": {"$eq": "Math"}}`.
</Note>

## POST Endpoint for Complex Queries

For longer or more complex queries, use the POST endpoint. The same `join` and `with` logic applies:

### Filter Only (join without with)
```
POST /api/data/entity/teacher/query
```

Body:
```json
{
  "where": { "subject.name": "Math" },
  "join": ["subject"]
}
```

### Filter and Embed (join with with)
```
POST /api/data/entity/teacher/query
```

Body:
```json
{
  "where": { "subject.name": "Math" },
  "join": ["subject"],
  "with": ["subject"]
}
```

### Complex Multi-Relation Example
```json
{
  "where": { 
    "subject.name": "Math",
    "department.budget": { "$gt": 50000 }
  },
  "join": ["subject", "department"],
  "with": ["subject"],
  "limit": 10,
  "sort": "name"
}
```

This example filters by both subject name and department budget, but only embeds subject data in the response.

## Read Many by Reference

If you have the Subject's ID and want to get all related Teachers quickly:

```
GET /api/data/entity/subject/1/teacher
```

This returns all Teachers related to Subject ID 1. You can still use `with` to embed additional relations:

```
GET /api/data/entity/subject/1/teacher?with=department
```

This returns teachers related to the subject, with their department information embedded.

## When to Use Each Parameter

### Use `join` when:
- You need to filter by related entity fields using dot notation
- You want to reference related data in your `where` conditions
- You don't necessarily need the related data in the response

### Use `with` when:
- You want to include related entity data in the response
- You need to avoid making additional API calls to fetch related data
- You want to reduce the number of requests for better performance

### Use both `join` and `with` when:
- You need to filter by related fields AND want the related data in the response
- You're building a UI that shows both the main entity and its relationships

### Performance Considerations:
- Using `join` without `with` is more efficient if you only need to filter
- Using `with` includes additional data transfer, so only request what you need
- Multiple joins can impact query performance on large datasets

## TypeScript SDK Usage

The TypeScript SDK provides a convenient way to work with the bknd API while automatically handling endpoint selection and query optimization. The SDK intelligently switches between GET and POST endpoints based on query complexity.

### Automatic Endpoint Selection

The SDK automatically chooses the most appropriate endpoint based on your query:

- **Simple queries**: Uses GET endpoint for better caching and performance
- **Complex queries**: Automatically switches to POST endpoint when URL length limits are approached
- **Transparent switching**: No code changes needed - the SDK handles this internally

#### Example: Simple Query (Uses GET)

**SDK Usage**:
```ts
import { Api } from "bknd/client";

const api = new Api();

// Simple filtering - SDK uses GET endpoint
const { data: teachers } = await api.data.readMany("teacher", {
   where: {
      name: "John Smith"
   },
   limit: 10
});
```

**Equivalent REST API Call**:
```
GET /api/data/entity/teacher?where={"name":"John Smith"}&limit=10
```

#### Example: Complex Query (Automatically Uses POST)

**SDK Usage**:
```ts
// Complex filtering - SDK automatically switches to POST
const { data: teachers } = await api.data.readMany("teacher", {
   where: {
      "$or": [
         {
            "$and": [
               { "subject.name": { "$in": ["Math", "Physics", "Chemistry"] } },
               { "department.budget": { "$gt": 50000 } }
            ]
         },
         {
            "$and": [
               { "experience": { "$gte": 10 } },
               { "rating": { "$gte": 4.5 } },
               { "certifications": { "$contains": "Advanced" } }
            ]
         }
      ]
   },
   join: ["subject", "department", "certifications"],
   with: {
      subject: {},
      department: { select: ["name", "budget"] }
   },
   sort: "-rating",
   limit: 50
});
```

**Equivalent REST API Call**:
```
POST /api/data/entity/teacher/query
Content-Type: application/json

{
  "where": {
    "$or": [
      {
        "$and": [
          { "subject.name": { "$in": ["Math", "Physics", "Chemistry"] } },
          { "department.budget": { "$gt": 50000 } }
        ]
      },
      {
        "$and": [
          { "experience": { "$gte": 10 } },
          { "rating": { "$gte": 4.5 } },
          { "certifications": { "$contains": "Advanced" } }
        ]
      }
    ]
  },
  "join": ["subject", "department", "certifications"],
  "with": ["subject", "department"],
  "sort": "-rating",
  "limit": 50
}
```

### Relationship Filtering with SDK

#### Filter Only (join without with)

**SDK Usage**:
```ts
// Get teachers who teach Math (no subject data in response)
const { data: mathTeachers } = await api.data.readMany("teacher", {
   where: {
      "subject.name": "Math"
   },
   join: ["subject"]
   // Note: no 'with' parameter, so subject data won't be included
});
```

**Equivalent REST API Call**:
```
GET /api/data/entity/teacher?where={"subject.name":"Math"}&join=subject
```

#### Embed Only (with without join)

**SDK Usage**:
```ts
// Get all teachers with their subjects embedded
const { data: teachersWithSubjects } = await api.data.readMany("teacher", {
   with: {
      subject: {}
   }
   // Note: no 'join' or 'where' with dot notation
});
```

**Equivalent REST API Call**:
```
GET /api/data/entity/teacher?with=subject
```

#### Filter and Embed (join + with)

**SDK Usage**:
```ts
// Get Math teachers with their subject data embedded
const { data: mathTeachersWithSubjects } = await api.data.readMany("teacher", {
   where: {
      "subject.name": "Math"
   },
   join: ["subject"],
   with: {
      subject: {}
   }
});
```

**Equivalent REST API Call**:
```
GET /api/data/entity/teacher?where={"subject.name":"Math"}&join=subject&with=subject
```

### Advanced SDK Features

#### Nested Relationships

**SDK Usage**:
```ts
// Get teachers with subjects and their departments
const { data: teachers } = await api.data.readMany("teacher", {
   where: {
      "subject.department.budget": { "$gt": 100000 }
   },
   join: ["subject", "subject.department"],
   with: {
      subject: {
         with: {
            department: {
               select: ["name", "budget"]
            }
         }
      }
   }
});
```

**Equivalent REST API Call**:
```
POST /api/data/entity/teacher/query
Content-Type: application/json

{
  "where": {
    "subject.department.budget": { "$gt": 100000 }
  },
  "join": ["subject", "subject.department"],
  "with": ["subject"],
  "limit": 50
}
```

#### Pagination with Relationships

**SDK Usage**:
```ts
// Paginated results with relationships
const { data: teachers, meta } = await api.data.readMany("teacher", {
   where: {
      "subject.name": { "$in": ["Math", "Physics"] }
   },
   join: ["subject"],
   with: {
      subject: {}
   },
   limit: 20,
   offset: 40, // Third page (20 * 2)
   sort: "name"
});

console.log(`Showing ${teachers.length} of ${meta.total} teachers`);
```

**Equivalent REST API Call**:
```
GET /api/data/entity/teacher?where={"subject.name":{"$in":["Math","Physics"]}}&join=subject&with=subject&limit=20&offset=40&sort=name
```

### SDK Best Practices

#### 1. Use Specific Selects for Performance

**Good Practice**:
```ts
// Only select needed fields to reduce payload size
const { data: teachers } = await api.data.readMany("teacher", {
   select: ["id", "name", "email"],
   where: {
      "subject.name": "Math"
   },
   join: ["subject"],
   with: {
      subject: {
         select: ["id", "name"] // Only get essential subject fields
      }
   }
});
```

**Avoid**:
```ts
// Don't fetch all fields if you only need a few
const { data: teachers } = await api.data.readMany("teacher", {
   where: {
      "subject.name": "Math"
   },
   join: ["subject"],
   with: {
      subject: {} // This fetches ALL subject fields
   }
});
```

#### 2. Minimize Joins for Better Performance

**Good Practice**:
```ts
// Only join relations you actually filter by
const { data: teachers } = await api.data.readMany("teacher", {
   where: {
      "subject.name": "Math"
   },
   join: ["subject"], // Only join what's needed for filtering
   with: {
      department: {} // Can embed without joining if not filtering
   }
});
```

**Avoid**:
```ts
// Don't join relations you don't filter by
const { data: teachers } = await api.data.readMany("teacher", {
   where: {
      "subject.name": "Math"
   },
   join: ["subject", "department", "certifications"], // Unnecessary joins
   with: {
      department: {}
   }
});
```

#### 3. Use Pagination for Large Datasets

**Good Practice**:
```ts
// Always use pagination for potentially large result sets
async function getAllMathTeachers() {
   const allTeachers = [];
   let offset = 0;
   const limit = 50;
   
   while (true) {
      const { data: teachers, meta } = await api.data.readMany("teacher", {
         where: { "subject.name": "Math" },
         join: ["subject"],
         limit,
         offset
      });
      
      allTeachers.push(...teachers);
      
      if (teachers.length < limit || offset + limit >= meta.total) {
         break;
      }
      
      offset += limit;
   }
   
   return allTeachers;
}
```

#### 4. Handle Errors Gracefully

**Good Practice**:
```ts
try {
   const { data: teachers } = await api.data.readMany("teacher", {
      where: {
         "subject.name": "Math"
      },
      join: ["subject"]
   });
   
   return teachers;
} catch (error) {
   if (error.message.includes("Invalid where field")) {
      console.error("Missing join parameter for relationship filtering");
      // Retry without relationship filtering or add proper join
   } else if (error.message.includes("Unknown relation")) {
      console.error("Check entity schema for correct relation names");
   }
   
   throw error;
}
```

#### 5. Optimize Complex Queries

**Good Practice**:
```ts
// For very complex queries, consider breaking them down
const complexQuery = {
   where: {
      "$or": [
         { "subject.name": { "$in": ["Math", "Physics"] } },
         { "department.budget": { "$gt": 50000 } }
      ]
   },
   join: ["subject", "department"],
   with: {
      subject: { select: ["name"] },
      department: { select: ["name", "budget"] }
   },
   sort: "-rating",
   limit: 100
};

// The SDK will automatically use POST for this complex query
const { data: teachers } = await api.data.readMany("teacher", complexQuery);
```

### SDK vs REST API Comparison

| Feature | SDK Advantage | REST API Advantage |
|---------|---------------|-------------------|
| **Endpoint Selection** | Automatic GET/POST switching | Full control over endpoint choice |
| **Type Safety** | TypeScript types and IntelliSense | Raw HTTP - no type checking |
| **Error Handling** | Structured error objects | Raw HTTP status codes |
| **Query Building** | Object-based query construction | Manual URL/JSON construction |
| **Caching** | Built-in request caching | Manual cache implementation |
| **Authentication** | Automatic token management | Manual header management |

### When to Use SDK vs Direct REST Calls

#### Use the TypeScript SDK when:
- Building TypeScript/JavaScript applications
- You want automatic endpoint optimization
- You need type safety and IntelliSense
- You prefer object-based query construction
- You want built-in error handling

#### Use Direct REST API when:
- Working with non-JavaScript languages
- You need fine-grained control over HTTP requests
- Building integrations with tools that expect REST endpoints
- You want to minimize client-side dependencies
- You're working with caching proxies or CDNs

### SDK Configuration for Optimal Performance

```ts
import { Api } from "bknd/client";

// Configure SDK for optimal performance
const api = new Api({
   host: "https://your-bknd-instance.com",
   token: "your-auth-token",
   // Optional: Configure request timeout
   timeout: 30000,
   // Optional: Enable request caching
   cache: true
});

// Verify authentication before making requests
await api.verifyAuth();
```

The TypeScript SDK provides a powerful, type-safe way to interact with the bknd API while automatically optimizing your queries for the best performance. It handles the complexity of endpoint selection, parameter serialization, and error handling, allowing you to focus on building your application logic.

## FAQ

**Q: Are `join` and `with` interchangeable?**

A: No. `join` allows you to use dot notation in filters. `with` specifies embedding related entities in the response. Use both if you want to both filter and receive the related data inline.

**Q: Can I use `with` without `join`?**

A: Yes! If you want to embed related data without filtering by it, you only need `with`. For example: `GET /api/data/entity/teacher?with=subject` returns all teachers with their subjects embedded.

**Q: What happens if I use dot notation in `where` without `join`?**

A: You'll get an error like "Invalid where field: subject.name". The `join` parameter is required to enable dot notation filtering.

**Q: Can I join multiple relations?**

A: Yes! Use arrays: `join=subject,department` or in POST: `"join": ["subject", "department"]`. You can then filter by fields from any joined relation: `where={"subject.name":"Math","department.budget":{"$gt":50000}}`.

**Q: Does `join` affect the response structure?**

A: No. `join` only enables filtering capabilities. It doesn't change what data is returned unless you also use `with`.

## Quick Reference

| Parameter | Purpose | When to Use | Example |
|-----------|---------|-------------|---------|
| `join` | Enables dot notation filtering | Need to filter by related fields | `join=subject` allows `where={"subject.name":"Math"}` |
| `with` | Embeds related data in response | Want related data included | `with=subject` includes subject objects in response |
| `where` | Filters results | Need to limit which records are returned | `where={"name":"John"}` or `where={"subject.name":"Math"}` (with join) |

## Common Patterns

| Use Case | Parameters | Example |
|----------|------------|---------|
| Filter only | `join` + `where` | `?where={"subject.name":"Math"}&join=subject` |
| Embed only | `with` | `?with=subject` |
| Filter + Embed | `join` + `with` + `where` | `?where={"subject.name":"Math"}&join=subject&with=subject` |
| Multiple relations | Arrays of relations | `?join=subject,department&with=subject` |

## Troubleshooting

### Common Error Scenarios

#### "Invalid where field" Error

**Error Message**: `Invalid where field(s): subject.name`

**Cause**: You're trying to use dot notation in a `where` clause without including the relation in the `join` parameter.

**Example of Incorrect Usage**:
```
GET /api/data/entity/teacher?where={"subject.name":"Math"}
```

**Solution**: Add the relation to the `join` parameter:
```
GET /api/data/entity/teacher?where={"subject.name":"Math"}&join=subject
```

**Why This Happens**: The database needs to know which tables to join before it can reference fields from related entities. The `join` parameter tells the API which relationships to include in the SQL query.

#### Malformed JSON in where Parameter

**Error Message**: `Invalid JSON in where parameter`

**Cause**: The `where` parameter contains invalid JSON syntax.

**Example of Incorrect Usage**:
```
GET /api/data/entity/teacher?where={name:"John"}  // Missing quotes around key
```

**Solution**: Ensure proper JSON formatting:
```
GET /api/data/entity/teacher?where={"name":"John"}
```

**Common JSON Mistakes**:
- Missing quotes around keys: `{name:"John"}` → `{"name":"John"}`
- Single quotes instead of double: `{'name':'John'}` → `{"name":"John"}`
- Trailing commas: `{"name":"John",}` → `{"name":"John"}`

#### Unknown Relation Error

**Error Message**: `Unknown relation: subjects`

**Cause**: You're referencing a relation that doesn't exist in the entity schema.

**Example of Incorrect Usage**:
```
GET /api/data/entity/teacher?join=subjects  // Relation name is wrong
```

**Solution**: Use the correct relation name:
```
GET /api/data/entity/teacher?join=subject  // Correct singular form
```

**How to Find Correct Relation Names**:
- Check your entity schema definition
- Use the `/api/system/schema` endpoint to see all available relations
- Relation names are typically singular (e.g., `subject`, not `subjects`)

#### URL Too Long Error

**Error Message**: `Request-URI Too Large` or `414 URI Too Long`

**Cause**: Your query parameters are too long for a GET request, typically when using complex `where` clauses.

**Example of Problematic Query**:
```
GET /api/data/entity/teacher?where={"$or":[{"subject.name":"Math"},{"subject.name":"Physics"},{"subject.name":"Chemistry"},{"department.name":"Science"},{"department.budget":{"$gt":50000},"$and":[{"experience":{"$gte":5}},{"rating":{"$gte":4.0}}]}]}&join=subject,department&with=subject,department
```

**Solution**: Switch to the POST endpoint:
```
POST /api/data/entity/teacher/query
Content-Type: application/json

{
  "where": {
    "$or": [
      {"subject.name": "Math"},
      {"subject.name": "Physics"},
      {"subject.name": "Chemistry"},
      {"department.name": "Science"},
      {
        "department.budget": {"$gt": 50000},
        "$and": [
          {"experience": {"$gte": 5}},
          {"rating": {"$gte": 4.0}}
        ]
      }
    ]
  },
  "join": ["subject", "department"],
  "with": ["subject", "department"]
}
```

### When to Switch from GET to POST

#### URL Length Guidelines

**Use GET when**:
- Simple filtering with 1-3 conditions
- Basic sorting and pagination
- URL length is under 2000 characters
- Query is cacheable and idempotent

**Switch to POST when**:
- Complex `where` clauses with multiple conditions
- Using `$or`, `$and` operators with many conditions
- URL approaches or exceeds 2000 characters
- Query contains special characters that need encoding

#### Complexity Indicators

**Simple Query (Use GET)**:
```
GET /api/data/entity/teacher?where={"name":"John"}&limit=10
```

**Medium Complexity (GET is OK)**:
```
GET /api/data/entity/teacher?where={"subject.name":"Math","experience":{"$gte":5}}&join=subject&with=subject
```

**High Complexity (Use POST)**:
```json
{
  "where": {
    "$or": [
      {
        "$and": [
          {"subject.name": {"$in": ["Math", "Physics", "Chemistry"]}},
          {"department.budget": {"$gt": 50000}}
        ]
      },
      {
        "$and": [
          {"experience": {"$gte": 10}},
          {"rating": {"$gte": 4.5}},
          {"certifications": {"$contains": "Advanced"}}
        ]
      }
    ]
  },
  "join": ["subject", "department", "certifications"],
  "with": ["subject"],
  "sort": "-rating",
  "limit": 50
}
```

### Performance Troubleshooting

#### Slow Query Performance

**Symptoms**: Queries taking longer than expected to return results.

**Common Causes and Solutions**:

1. **Too Many Joins**
   - **Problem**: Joining multiple large tables
   - **Solution**: Only join relations you actually filter by
   - **Example**: If you only need to embed data, use `with` without `join`

2. **Missing Indexes**
   - **Problem**: Filtering by unindexed fields
   - **Solution**: Ensure database indexes exist on frequently filtered fields
   - **Check**: Review your database schema for proper indexing

3. **Large Result Sets**
   - **Problem**: Returning too many records
   - **Solution**: Use `limit` parameter to paginate results
   - **Example**: `?limit=50&offset=0` for first page

#### Memory Issues

**Error Message**: `Request entity too large` or timeout errors

**Cause**: Trying to return too much data in a single request.

**Solutions**:
- Reduce `limit` parameter (default is 50, max is usually 1000)
- Use pagination with `offset`
- Avoid embedding large relations with `with` unless necessary
- Filter results more specifically with `where`

### Debugging Tips

#### Test Your Queries Step by Step

1. **Start Simple**: Begin with basic filtering without relations
   ```
   GET /api/data/entity/teacher?where={"name":"John"}
   ```

2. **Add Relations Gradually**: Add one relation at a time
   ```
   GET /api/data/entity/teacher?where={"name":"John"}&join=subject
   ```

3. **Add Dot Notation**: Test filtering by related fields
   ```
   GET /api/data/entity/teacher?where={"subject.name":"Math"}&join=subject
   ```

4. **Add Embedding**: Include related data in response
   ```
   GET /api/data/entity/teacher?where={"subject.name":"Math"}&join=subject&with=subject
   ```

#### Use Browser Developer Tools

- Check the **Network** tab to see the actual request being sent
- Look at the **Response** tab to see error details
- Copy the request as cURL to test outside the browser

#### Validate JSON

Before using complex `where` clauses, validate your JSON:
- Use online JSON validators
- Test JSON parsing in your browser console: `JSON.parse('{"name":"John"}')`
- Use proper escaping for special characters

### Error Response Format

All API errors follow this format:

```json
{
  "error": {
    "code": "ERROR_CODE",
    "message": "Human-readable error message",
    "details": "Additional context about the error"
  }
}
```

**Common Error Codes**:
- `INVALID_PARAMETER`: Invalid query parameter format
- `UNKNOWN_RELATION`: Referenced relation doesn't exist
- `INVALID_WHERE_FIELD`: Dot notation used without proper join
- `REQUEST_TOO_LARGE`: Query too complex for GET request
- `MALFORMED_JSON`: Invalid JSON in where parameter

This troubleshooting guide will help you identify and resolve common issues when working with the bknd filtering API. Remember: start simple, test incrementally, and switch to POST for complex queries.
