---
title: 'Filtering by Relations'
description: 'How to filter entities based on related data in many-to-many relationships'
---

You often need to retrieve entries from one entity based on properties of a related entity (for example, get all Teachers who teach "Math"). In bknd, this is handled via the REST API using the `where` clause with dot notation, together with the `join` parameter.

## Understanding `join` vs `with`

Before diving into examples, it's crucial to understand the functional difference between these two parameters:

- **`join`**: Enables filtering by related entity fields using dot notation. This parameter tells the database to join the related table so you can reference its fields in your `where` conditions. The related data is **not** included in the response unless you also use `with`.

- **`with`**: Embeds related entity data in the response. This parameter tells the API to include the full related objects in the returned results. You can use `with` without `join` if you only want to embed data without filtering by it.

**Key Point**: `join` is about **filtering capabilities**, while `with` is about **response structure**.

## Example Use Case

You have:
- An entity: `Teacher`
- Another entity: `Subject`
- Many-to-many relation between them (a Teacher can have many Subjects, and vice versa).

You want to find Teachers that have a Subject with the name 'Math'.

## Examples by Use Case

### 1. Filter by Related Data (join only)

When you want to filter by related entity fields but don't need the related data in the response:

```
GET /api/data/entity/teacher?where={"subject.name":"Math"}&join=subject
```

**Result**: Returns teachers who teach Math, but the response only contains teacher data (no embedded subject information).

```json
{
  "data": [
    {
      "id": 1,
      "name": "John Smith",
      "email": "john@school.edu"
    }
  ]
}
```

### 2. Embed Related Data (with only)

When you want to include related data in the response without filtering by it:

```
GET /api/data/entity/teacher?with=subject
```

**Result**: Returns all teachers with their subjects embedded in the response.

```json
{
  "data": [
    {
      "id": 1,
      "name": "John Smith",
      "email": "john@school.edu",
      "subject": [
        {
          "id": 1,
          "name": "Math",
          "description": "Mathematics course"
        },
        {
          "id": 2,
          "name": "Physics",
          "description": "Physics course"
        }
      ]
    }
  ]
}
```

### 3. Filter and Embed (join + with)

When you want both to filter by related data AND include it in the response:

```
GET /api/data/entity/teacher?where={"subject.name":"Math"}&join=subject&with=subject
```

**Result**: Returns teachers who teach Math, with their subject data embedded.

```json
{
  "data": [
    {
      "id": 1,
      "name": "John Smith",
      "email": "john@school.edu",
      "subject": [
        {
          "id": 1,
          "name": "Math",
          "description": "Mathematics course"
        }
      ]
    }
  ]
}
```

<Note>
If no operation is provided in the where clause, `$eq` (equals) is assumed by default. So `{"subject.name": "Math"}` is the same as `{"subject.name": {"$eq": "Math"}}`.
</Note>

## POST Endpoint for Complex Queries

For longer or more complex queries, use the POST endpoint. The same `join` and `with` logic applies:

### Filter Only (join without with)
```
POST /api/data/entity/teacher/query
```

Body:
```json
{
  "where": { "subject.name": "Math" },
  "join": ["subject"]
}
```

### Filter and Embed (join with with)
```
POST /api/data/entity/teacher/query
```

Body:
```json
{
  "where": { "subject.name": "Math" },
  "join": ["subject"],
  "with": ["subject"]
}
```

### Complex Multi-Relation Example
```json
{
  "where": { 
    "subject.name": "Math",
    "department.budget": { "$gt": 50000 }
  },
  "join": ["subject", "department"],
  "with": ["subject"],
  "limit": 10,
  "sort": "name"
}
```

This example filters by both subject name and department budget, but only embeds subject data in the response.

## Read Many by Reference

If you have the Subject's ID and want to get all related Teachers quickly:

```
GET /api/data/entity/subject/1/teacher
```

This returns all Teachers related to Subject ID 1. You can still use `with` to embed additional relations:

```
GET /api/data/entity/subject/1/teacher?with=department
```

This returns teachers related to the subject, with their department information embedded.

## When to Use Each Parameter

### Use `join` when:
- You need to filter by related entity fields using dot notation
- You want to reference related data in your `where` conditions
- You don't necessarily need the related data in the response

### Use `with` when:
- You want to include related entity data in the response
- You need to avoid making additional API calls to fetch related data
- You want to reduce the number of requests for better performance

### Use both `join` and `with` when:
- You need to filter by related fields AND want the related data in the response
- You're building a UI that shows both the main entity and its relationships

### Performance Considerations:
- Using `join` without `with` is more efficient if you only need to filter
- Using `with` includes additional data transfer, so only request what you need
- Multiple joins can impact query performance on large datasets

## Example in TypeScript SDK

The TypeScript SDK will automatically choose the right endpoint if your query URL gets too long.

```ts
import { Api } from "bknd/client";

const api = new Api();

// Filter teachers by subject name
const { data: teachers } = await api.data.readMany("teacher", {
   where: {
      "subject.name": "Math"
   },
   join: ["subject"],
   with: {
      subject: {}
   }
});
```

## FAQ

**Q: Are `join` and `with` interchangeable?**

A: No. `join` allows you to use dot notation in filters. `with` specifies embedding related entities in the response. Use both if you want to both filter and receive the related data inline.

**Q: Can I use `with` without `join`?**

A: Yes! If you want to embed related data without filtering by it, you only need `with`. For example: `GET /api/data/entity/teacher?with=subject` returns all teachers with their subjects embedded.

**Q: What happens if I use dot notation in `where` without `join`?**

A: You'll get an error like "Invalid where field: subject.name". The `join` parameter is required to enable dot notation filtering.

**Q: Can I join multiple relations?**

A: Yes! Use arrays: `join=subject,department` or in POST: `"join": ["subject", "department"]`. You can then filter by fields from any joined relation: `where={"subject.name":"Math","department.budget":{"$gt":50000}}`.

**Q: Does `join` affect the response structure?**

A: No. `join` only enables filtering capabilities. It doesn't change what data is returned unless you also use `with`.

## Quick Reference

| Parameter | Purpose | When to Use | Example |
|-----------|---------|-------------|---------|
| `join` | Enables dot notation filtering | Need to filter by related fields | `join=subject` allows `where={"subject.name":"Math"}` |
| `with` | Embeds related data in response | Want related data included | `with=subject` includes subject objects in response |
| `where` | Filters results | Need to limit which records are returned | `where={"name":"John"}` or `where={"subject.name":"Math"}` (with join) |

## Common Patterns

| Use Case | Parameters | Example |
|----------|------------|---------|
| Filter only | `join` + `where` | `?where={"subject.name":"Math"}&join=subject` |
| Embed only | `with` | `?with=subject` |
| Filter + Embed | `join` + `with` + `where` | `?where={"subject.name":"Math"}&join=subject&with=subject` |
| Multiple relations | Arrays of relations | `?join=subject,department&with=subject` |

## Troubleshooting

### Common Error Scenarios

#### "Invalid where field" Error

**Error Message**: `Invalid where field(s): subject.name`

**Cause**: You're trying to use dot notation in a `where` clause without including the relation in the `join` parameter.

**Example of Incorrect Usage**:
```
GET /api/data/entity/teacher?where={"subject.name":"Math"}
```

**Solution**: Add the relation to the `join` parameter:
```
GET /api/data/entity/teacher?where={"subject.name":"Math"}&join=subject
```

**Why This Happens**: The database needs to know which tables to join before it can reference fields from related entities. The `join` parameter tells the API which relationships to include in the SQL query.

#### Malformed JSON in where Parameter

**Error Message**: `Invalid JSON in where parameter`

**Cause**: The `where` parameter contains invalid JSON syntax.

**Example of Incorrect Usage**:
```
GET /api/data/entity/teacher?where={name:"John"}  // Missing quotes around key
```

**Solution**: Ensure proper JSON formatting:
```
GET /api/data/entity/teacher?where={"name":"John"}
```

**Common JSON Mistakes**:
- Missing quotes around keys: `{name:"John"}` → `{"name":"John"}`
- Single quotes instead of double: `{'name':'John'}` → `{"name":"John"}`
- Trailing commas: `{"name":"John",}` → `{"name":"John"}`

#### Unknown Relation Error

**Error Message**: `Unknown relation: subjects`

**Cause**: You're referencing a relation that doesn't exist in the entity schema.

**Example of Incorrect Usage**:
```
GET /api/data/entity/teacher?join=subjects  // Relation name is wrong
```

**Solution**: Use the correct relation name:
```
GET /api/data/entity/teacher?join=subject  // Correct singular form
```

**How to Find Correct Relation Names**:
- Check your entity schema definition
- Use the `/api/system/schema` endpoint to see all available relations
- Relation names are typically singular (e.g., `subject`, not `subjects`)

#### URL Too Long Error

**Error Message**: `Request-URI Too Large` or `414 URI Too Long`

**Cause**: Your query parameters are too long for a GET request, typically when using complex `where` clauses.

**Example of Problematic Query**:
```
GET /api/data/entity/teacher?where={"$or":[{"subject.name":"Math"},{"subject.name":"Physics"},{"subject.name":"Chemistry"},{"department.name":"Science"},{"department.budget":{"$gt":50000},"$and":[{"experience":{"$gte":5}},{"rating":{"$gte":4.0}}]}]}&join=subject,department&with=subject,department
```

**Solution**: Switch to the POST endpoint:
```
POST /api/data/entity/teacher/query
Content-Type: application/json

{
  "where": {
    "$or": [
      {"subject.name": "Math"},
      {"subject.name": "Physics"},
      {"subject.name": "Chemistry"},
      {"department.name": "Science"},
      {
        "department.budget": {"$gt": 50000},
        "$and": [
          {"experience": {"$gte": 5}},
          {"rating": {"$gte": 4.0}}
        ]
      }
    ]
  },
  "join": ["subject", "department"],
  "with": ["subject", "department"]
}
```

### When to Switch from GET to POST

#### URL Length Guidelines

**Use GET when**:
- Simple filtering with 1-3 conditions
- Basic sorting and pagination
- URL length is under 2000 characters
- Query is cacheable and idempotent

**Switch to POST when**:
- Complex `where` clauses with multiple conditions
- Using `$or`, `$and` operators with many conditions
- URL approaches or exceeds 2000 characters
- Query contains special characters that need encoding

#### Complexity Indicators

**Simple Query (Use GET)**:
```
GET /api/data/entity/teacher?where={"name":"John"}&limit=10
```

**Medium Complexity (GET is OK)**:
```
GET /api/data/entity/teacher?where={"subject.name":"Math","experience":{"$gte":5}}&join=subject&with=subject
```

**High Complexity (Use POST)**:
```json
{
  "where": {
    "$or": [
      {
        "$and": [
          {"subject.name": {"$in": ["Math", "Physics", "Chemistry"]}},
          {"department.budget": {"$gt": 50000}}
        ]
      },
      {
        "$and": [
          {"experience": {"$gte": 10}},
          {"rating": {"$gte": 4.5}},
          {"certifications": {"$contains": "Advanced"}}
        ]
      }
    ]
  },
  "join": ["subject", "department", "certifications"],
  "with": ["subject"],
  "sort": "-rating",
  "limit": 50
}
```

### Performance Troubleshooting

#### Slow Query Performance

**Symptoms**: Queries taking longer than expected to return results.

**Common Causes and Solutions**:

1. **Too Many Joins**
   - **Problem**: Joining multiple large tables
   - **Solution**: Only join relations you actually filter by
   - **Example**: If you only need to embed data, use `with` without `join`

2. **Missing Indexes**
   - **Problem**: Filtering by unindexed fields
   - **Solution**: Ensure database indexes exist on frequently filtered fields
   - **Check**: Review your database schema for proper indexing

3. **Large Result Sets**
   - **Problem**: Returning too many records
   - **Solution**: Use `limit` parameter to paginate results
   - **Example**: `?limit=50&offset=0` for first page

#### Memory Issues

**Error Message**: `Request entity too large` or timeout errors

**Cause**: Trying to return too much data in a single request.

**Solutions**:
- Reduce `limit` parameter (default is 50, max is usually 1000)
- Use pagination with `offset`
- Avoid embedding large relations with `with` unless necessary
- Filter results more specifically with `where`

### Debugging Tips

#### Test Your Queries Step by Step

1. **Start Simple**: Begin with basic filtering without relations
   ```
   GET /api/data/entity/teacher?where={"name":"John"}
   ```

2. **Add Relations Gradually**: Add one relation at a time
   ```
   GET /api/data/entity/teacher?where={"name":"John"}&join=subject
   ```

3. **Add Dot Notation**: Test filtering by related fields
   ```
   GET /api/data/entity/teacher?where={"subject.name":"Math"}&join=subject
   ```

4. **Add Embedding**: Include related data in response
   ```
   GET /api/data/entity/teacher?where={"subject.name":"Math"}&join=subject&with=subject
   ```

#### Use Browser Developer Tools

- Check the **Network** tab to see the actual request being sent
- Look at the **Response** tab to see error details
- Copy the request as cURL to test outside the browser

#### Validate JSON

Before using complex `where` clauses, validate your JSON:
- Use online JSON validators
- Test JSON parsing in your browser console: `JSON.parse('{"name":"John"}')`
- Use proper escaping for special characters

### Error Response Format

All API errors follow this format:

```json
{
  "error": {
    "code": "ERROR_CODE",
    "message": "Human-readable error message",
    "details": "Additional context about the error"
  }
}
```

**Common Error Codes**:
- `INVALID_PARAMETER`: Invalid query parameter format
- `UNKNOWN_RELATION`: Referenced relation doesn't exist
- `INVALID_WHERE_FIELD`: Dot notation used without proper join
- `REQUEST_TOO_LARGE`: Query too complex for GET request
- `MALFORMED_JSON`: Invalid JSON in where parameter

This troubleshooting guide will help you identify and resolve common issues when working with the bknd filtering API. Remember: start simple, test incrementally, and switch to POST for complex queries.
