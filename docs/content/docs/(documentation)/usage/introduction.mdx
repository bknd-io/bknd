---
title: "Introduction"
description: "Setting up bknd"
icon: Pin
tags: ["documentation"]
---

import { TypeTable } from "fumadocs-ui/components/type-table";
import { SquareMousePointer, Code, Blend } from 'lucide-react';

There are several methods to get **bknd** up and running. You can choose between these options:

1. [Run it using the CLI](/usage/cli): That's the easiest and fastest way to get started.
2. Use a runtime like [Node](/integration/node), [Bun](/integration/bun) or
   [Cloudflare](/integration/cloudflare) (workerd). This will run the API and UI in the runtime's
   native server and serves the UI assets statically from `node_modules`.
3. Run it inside your React framework of choice like [Next.js](/integration/nextjs),
   [Astro](/integration/astro) or [Remix](/integration/remix).

There is also a fourth option, which is running it inside a
[Docker container](/integration/docker). This is essentially a wrapper around the CLI.

## Basic setup

Regardless of the method you choose, at the end all adapters come down to the actual
instantiation of the `App`, which in raw looks like this:

```typescript
import { createApp, type BkndConfig } from "bknd";

// create the app
const config = {
  /* ... */
} satisfies BkndConfig;
const app = createApp(config);

// build the app
await app.build();

// export for Web API compliant envs
export default app;
```

In Web API compliant environments, all you have to do is to default exporting the app, as it
implements the `Fetch` API.

## Modes

Main project goal is to provide a backend that can be configured visually with the built-in Admin UI. However, you may instead want to configure your backend programmatically, and define your data structure with a Drizzle-like API:

<Cards className="grid-cols-1 sm:grid-cols-2 md:grid-cols-3">
  <Card title="UI-only" href="/usage/introduction#ui-only-mode" icon={<SquareMousePointer className="text-fd-primary !size-6" />}>
     This is the default mode, it allows visual configuration and saves the configuration to the database. Expects you to deploy your backend separately from your frontend.
  </Card>
  <Card title="Code-only" href="/usage/introduction#code-only-mode" icon={<Code className="text-fd-primary !size-6" />}>
    This mode allows you to configure your backend programmatically, and define your data structure with a Drizzle-like API. Visual configuration controls are disabled. 
  </Card>
  <Card title={"Hybrid"} href="/usage/introduction#hybrid-mode" icon={<Blend className="text-fd-primary !size-6" />}>
    This mode allows you to configure your backend visually while in development, and uses the produced configuration in a code-only mode for maximum performance. 
  </Card>
</Cards>

In the following sections, we'll cover the different modes in more detail. The configuration properties involved are the following:

```typescript title="bknd.config.ts"
import type { BkndConfig } from "bknd";

export default {
  config: { /* ... */ }
  options: {
    mode: "db", // or "code"
    manager: {
      secrets: { /* ... */ },
      storeSecrets: true,
    },
  }
} satisfies BkndConfig;
```

<TypeTable type={{
  config: {
    description: "The initial configuration when `mode` is `\"db\"`, and as the produced configuration when `mode` is `\"code\"`.",
    type: "object",
    properties: {
      /* ... */
    }
  },
  ["options.mode"]: {
    description: "The options for the app.",
    type: '"db" | "code"',
    default: '"db"'
  },
  ["options.manager.secrets"]: {
    description: "The app secrets to be provided when using `\"db\"` mode. This is required since secrets are extracted and stored separately to the database.",
    type: "object",
    properties: {
      /* ... */
    }
  },
  ["options.manager.storeSecrets"]: {
    description: "Whether to store secrets in the database when using `\"db\"` mode.",
    type: "boolean",
    default: "true"
  }
}} />

### UI-only mode

This mode is the default mode. It allows you to configure your backend visually with the built-in Admin UI. It expects that you deploy your backend separately from your frontend, and make changes there. No configuration is needed, however, if you want to provide an initial configuration, you can do so by passing a `config` object.

```typescript
import type { BkndConfig } from "bknd";

export default {
  // this will only be applied if the database is empty
  config: { /* ... */ },
} satisfies BkndConfig;
```

### Code-only mode

This mode allows you to configure your backend programmatically, and define your data structure with a Drizzle-like API. Visual configuration controls are disabled. 

```typescript title="bknd.config.ts"
import { type BkndConfig, em, entity, text, boolean } from "bknd";
import { secureRandomString } from "bknd/utils";

const schema = em({
  todos: entity("todos", {
    title: text(),
    done: boolean(),
  }),
});

export default {
  // example configuration
  config: {
    data: schema.toJSON(),
    auth: {
      enabled: true,
      jwt: {
        secret: secureRandomString(64),
      },
    }
  },
  options: {
    // this ensures that the provided configuration is always used
    mode: "code",
  },
} satisfies BkndConfig;
```

### Hybrid mode

This mode allows you to configure your backend visually while in development, and uses the produced configuration in a code-only mode for maximum performance. It gives you the best of both worlds.

While in development, we set the mode to `"db"` where the configuration is stored in the database. When it's time to deploy, we export the configuration, and set the mode to `"code"`. While in `"db"` mode, the `config` property interprets the value as an initial configuration to use when the database is empty.

```typescript title="bknd.config.ts"
import type { BkndConfig } from "bknd";

// import your produced configuration
import appConfig from "./appconfig.json" with { type: "json" };

export default {
  config: appConfig,
  options: {
    mode: process.env.NODE_ENV === "development" ? "db" : "code",
    manager: {
      secrets: process.env
    }
  },
} satisfies BkndConfig;
```

To keep your config, secrets and types in sync, you can either use the CLI or the plugins.


| Type           | Plugin                                                                 | CLI Command                |
|----------------|-----------------------------------------------------------------------|----------------------------|
| Configuration  | [`syncConfig`](/extending/plugins/#syncconfig)                        | [`config`](/usage/cli/#getting-the-configuration-config)   |
| Secrets        | [`syncSecrets`](/extending/plugins/#syncsecrets)                      | [`secrets`](/usage/cli/#getting-the-secrets-secrets) |
| Types          | [`syncTypes`](/extending/plugins/#synctypes)                          | [`types`](/usage/cli/#generating-types-types)     |



## Configuration (`BkndConfig`)

The `BkndConfig` type is the main configuration object for the `createApp` function. It has
the following properties:

```typescript
import type { App, InitialModuleConfigs, ModuleBuildContext, Connection, MaybePromise } from "bknd";
import type { Config } from "@libsql/client";

type AppPlugin = (app: App) => Promise<void> | void;
type ManagerOptions = {
  basePath?: string;
  trustFetched?: boolean;
  onFirstBoot?: () => Promise<void>;
  seed?: (ctx: ModuleBuildContext) => Promise<void>;
};

type BkndConfig<Args = any> = {
  connection?: Connection | Config;
  config?: InitialModuleConfigs;
  options?: {
    plugins?: AppPlugin[];
    manager?: ManagerOptions;
  };
  app?: BkndConfig<Args> | ((args: Args) => MaybePromise<BkndConfig<Args>>);
  onBuilt?: (app: App) => Promise<void>;
  beforeBuild?: (app?: App) => Promise<void>;
  buildConfig?: {
    sync?: boolean;
  }
};
```

### `connection`

The `connection` property is the main connection object to the database. It can be either an object with libsql config or the actual `Connection` class.

```ts
// uses the default SQLite connection depending on the runtime
const connection = { url: "<url>" };

// the same as above, but more explicit
import { sqlite } from "bknd/adapter/sqlite";
const connection = sqlite({ url: "<url>" });

// Node.js SQLite, default on Node.js
import { nodeSqlite } from "bknd/adapter/node";
const connection = nodeSqlite({ url: "<url>" });

// Bun SQLite, default on Bun
import { bunSqlite } from "bknd/adapter/bun";
const connection = bunSqlite({ url: "<url>" });

// LibSQL, default on Cloudflare
import { libsql } from "bknd";
const connection = libsql({ url: "<url>" });
```

See a full list of available connections in the [Database](/usage/database) section. Alternatively, you can pass an instance of a `Connection` class directly, see [Custom Connection](/usage/database#custom-connection) as a reference.

If the connection object is omitted, the app will try to use an in-memory database.

### `config`

As [initial configuration](/usage/database#initial-structure), you can either pass a partial configuration object or a complete one
with a version number. The version number is used to automatically migrate the configuration up
to the latest version upon boot. The default configuration looks like this:

```json
{
  "server": {
    "admin": {
      "basepath": "",
      "color_scheme": "light",
      "logo_return_path": "/"
    },
    "cors": {
      "origin": "*",
      "allow_methods": ["GET", "POST", "PATCH", "PUT", "DELETE"],
      "allow_headers": [
        "Content-Type",
        "Content-Length",
        "Authorization",
        "Accept"
      ]
    }
  },
  "data": {
    "basepath": "/api/data",
    "entities": {},
    "relations": {},
    "indices": {}
  },
  "auth": {
    "enabled": false,
    "basepath": "/api/auth",
    "entity_name": "users",
    "allow_register": true,
    "jwt": {
      "secret": "",
      "alg": "HS256",
      "fields": ["id", "email", "role"]
    },
    "cookie": {
      "path": "/",
      "sameSite": "lax",
      "secure": true,
      "httpOnly": true,
      "expires": 604800,
      "renew": true,
      "pathSuccess": "/",
      "pathLoggedOut": "/"
    },
    "strategies": {
      "password": {
        "type": "password",
        "config": {
          "hashing": "sha256"
        }
      }
    },
    "roles": {}
  },
  "media": {
    "enabled": false,
    "basepath": "/api/media",
    "entity_name": "media",
    "storage": {}
  },
  "flows": {
    "basepath": "/api/flows",
    "flows": {}
  }
}
```

You can use the [CLI](/usage/cli/#getting-the-configuration-config) to get the default configuration:

```sh
npx bknd config --default --pretty
```

To validate your configuration against a JSON schema, you can also dump the schema using the CLI:

```sh
npx bknd schema
```

To create an initial data structure, you can use helpers [described here](/usage/database#initial-structure).

### `options.plugins`

The `plugins` property is an array of functions that are called after the app has been built,
but before its event is emitted. This is useful for adding custom routes or other functionality.
A simple plugin that adds a custom route looks like this:

```ts
import type { AppPlugin } from "bknd";

export const myPlugin: AppPlugin = (app) => {
  app.server.get("/hello", (c) => c.json({ hello: "world" }));
};
```

Since each plugin has full access to the `app` instance, it can add routes, modify the database
structure, add custom middlewares, respond to or add events, etc. Plugins are very powerful, so
make sure to only run trusted ones.

### `options.seed`

<Callout type="info">
  The seed function will only be executed on app's first boot in `"db"` mode. If a configuration already exists in the database, or in `"code"` mode, it will not be executed.
</Callout>

The `seed` property is a function that is called when the app is booted for the first time. It is used to seed the database with initial data. The function is passed a `ModuleBuildContext` object:

```ts
type ModuleBuildContext = {
  connection: Connection;
  server: Hono;
  em: EntityManager;
  emgr: EventManager;
  guard: Guard;
};

const seed = async (ctx: ModuleBuildContext) => {
  // seed the database
  await ctx.em.mutator("todos").insertMany([
    { title: "Learn bknd", done: true },
    { title: "Build something cool", done: false },
  ]);
};
```

